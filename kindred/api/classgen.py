__all__ = ["gen_typescript"]


def gen_typescript(api, outfile):
    write_module_header(outfile)
    for name in sorted(api._registry.keys()):
        write_class(outfile, api._registry[name], api._registry)
    write_module_footer(outfile)


def write_module_header(outfile):
    outfile.write("""// autogenerated file -- do not edit

module GenModels {
  'use strict';

  export type ResourceUri = string;
  export type ApiDateTime = string;
  export type ApiDate = ApiDateTime;
  export interface ApiDict {
    [index: string]: any;
  }

""")


def write_module_footer(outfile):
    outfile.write("""}
// end of module GenModels (duh)
""")


def write_class(outfile, resource, registry):
    resource_name = resource._meta.resource_name
    iface = iface_body(resource, registry)
    outfile.write("  export interface %s extends Models.BaseModel %s\n"
                  % (resource_name, iface))
    outfile.write("  export type %s_id = number;\n" % resource_name)
    outfile.write("  export type %s_uri = ResourceUri;\n" % resource_name)
    outfile.write("\n")


def iface_body(resource, registry, indent=1, anonymous=False):
    def mkfield(fieldname):
        return iface_field(resource, fieldname,
                           resource.fields[fieldname],
                           anonymous, registry)
    fields = map(mkfield, sorted(resource.fields))
    indent = "  " * indent
    return "{\n%s%s}" % ("".join(["%s  %s;\n" % (indent, f) for f in fields]), indent)


def iface_field(resource, name, field, anonymous, registry):
    def non_keyword(name):
        keywords = {"type", "export", "default"}
        keywords = []
        return ("_" + name) if name in keywords else name
    ts, req = typescript_type(name, field, resource, anonymous, registry)
    return "%s%s: %s" % (non_keyword(name), "" if req else "?", ts)


def typescript_type(name, field, resource, anonymous, registry):
    mapping = {
        "integer": ["number"],
        "float": ["number"],
        "string": ["string"],
        "boolean": ["boolean"],
        "datetime": ["ApiDateTime"],
        "date": ["ApiDate"],
        "dict": ["ApiDict"],
        "list": ["any[]"],
    }
    t = mapping.get(field.dehydrated_type, [])
    multi = False
    if not t and field.dehydrated_type == "related":
        related_resource = field.to_class()
        related_name = related_resource._meta.resource_name
        if related_name in registry:
            t = ["%s_id" % related_name, "%s_uri" % related_name]
            if field.full or field.full_detail or field.field_list:
                t.append(related_name)
        else:
            t = [iface_body(related_resource, registry, 2, True)]
        multi = getattr(field, 'is_m2m', False)
    elif not anonymous and field.dehydrated_type == "integer" and name == "id":
        t = ["%s_id" % resource._meta.resource_name]
    elif not anonymous and field.dehydrated_type == "string" and name == "resource_uri":
        t = ["%s_uri" % resource._meta.resource_name]
    elif type(field).__name__ == "SpaceListField":
        t = ["string"]
        multi = True

    required = name not in ["id", "resource_uri"]

    def fmt(t, multi):
        text = " | ".join(t) or "any"
        if multi and len(t) > 1:
            text = "(%s)[]" % text
        elif multi:
            text += "[]"
        return text

    return (fmt(t, multi), required)
